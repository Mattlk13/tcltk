/*
 * tkMacOSXWindowEvent.c --
 *
 *	This file defines the routines for both creating and handling Window
 *	Manager class events for Tk.
 *
 * Copyright 2001, Apple Computer, Inc.
 * Copyright (c) 2005-2009 Daniel A. Steffen <das@users.sourceforge.net>
 * Copyright 2008-2009, Apple Inc.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @(#) $Id$
 */

#include "tkMacOSXPrivate.h"
#include "tkMacOSXWm.h"
#include "tkMacOSXEvent.h"
#include "tkMacOSXDebug.h"

/*
#ifdef TK_MAC_DEBUG
#define TK_MAC_DEBUG_EVENTS
#define TK_MAC_DEBUG_DRAWING
#endif
*/

/*
 * Declaration of functions used only in this file
 */

static int		GenerateUpdates(HIMutableShapeRef updateRgn,
			    CGRect *updateBounds, TkWindow *winPtr);
static int		GenerateActivateEvents(Window window, int activeFlag);

#pragma mark TKApplication(TKWindowEvent)

extern NSString *NSWindowWillOrderOnScreenNotification;
extern NSString *NSWindowDidOrderOffScreenNotification;

#if MAC_OS_X_VERSION_MIN_REQUIRED < 1060
#define NSWindowWillStartLiveResizeNotification @"NSWindowWillStartLiveResizeNotification"
#define NSWindowDidEndLiveResizeNotification  @"NSWindowDidEndLiveResizeNotification"
#endif

@implementation TKApplication(TKWindowEvent)
- (void)windowActivation:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    BOOL activate = [[notification name] isEqualToString:NSWindowDidBecomeKeyNotification];
    NSWindow *w = [notification object];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);

    if (winPtr) {
	GenerateActivateEvents(winPtr->window, activate);
	TkMacOSXGenerateFocusEvent(winPtr->window, activate);
	TkMacOSXEnterExitFullscreen(winPtr, activate);
    }
}
- (void)windowDragStart:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
}
- (void)windowBoundsChanged:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    BOOL movedOnly = [[notification name] isEqualToString:NSWindowDidMoveNotification];
    if (movedOnly) {
	/* constraining to screen after move not needed with AppKit */
    }
    NSWindow *w = [notification object];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);

    if (winPtr) {
	WmInfo *wmPtr = winPtr->wmInfoPtr;
	NSRect bounds = [w frame];
	int x, y, width = -1, height = -1, flags = 0;

	x = bounds.origin.x;
	y = tkMacOSXZeroScreenHeight - (bounds.origin.y + bounds.size.height);
	if (winPtr->changes.x != x || winPtr->changes.y != y){
	    flags |= TK_LOCATION_CHANGED;
	} else {
	    x = y = -1;
	}
	if (!movedOnly && (winPtr->changes.width != bounds.size.width ||
		winPtr->changes.height !=  bounds.size.height)) {
	    width = bounds.size.width - wmPtr->xInParent;
	    height = bounds.size.height - wmPtr->yInParent;
	    flags |= TK_SIZE_CHANGED;
	}
	TkMacOSXInvalClipRgns((Tk_Window) winPtr);
	TkMacOSXInvalidateWindow((MacDrawable*) winPtr->window, TK_PARENT_WINDOW);
	TkGenWMConfigureEvent((Tk_Window)winPtr, x, y, width, height,
		flags);
	/*
	if (wmPtr->attributes & kWindowResizableAttribute) {
	    [w setShowsResizeIndicator:NO];
	    [w setShowsResizeIndicator:YES];
	}
	*/
    }
}
- (void)windowLiveResize:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    //BOOL start = [[notification name] isEqualToString:NSWindowWillStartLiveResizeNotification];
}
/* TODO: this is received too late (after NSWindowDidBecomeKeyNotification) */
- (void)windowExpanded:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    NSWindow *w = [notification object];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);

    if (winPtr) {
	winPtr->wmInfoPtr->hints.initial_state =
		TkMacOSXIsWindowZoomed(winPtr) ? ZoomState : NormalState;
	Tk_MapWindow((Tk_Window) winPtr);
	/* Process all Tk events generated by Tk_MapWindow() */
	//while (Tcl_ServiceEvent(TCL_WINDOW_EVENTS)) {/*empty body*/};
	while (Tcl_DoOneEvent(TCL_IDLE_EVENTS)) {/*empty body*/};
    }
}
- (void)windowCollapsed:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    NSWindow *w = [notification object];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);

    if (winPtr) {
	Tk_UnmapWindow((Tk_Window) winPtr);
    }
}
- (void)windowMapped:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    NSWindow *w = [notification object];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);

    if (winPtr) {
	//Tk_MapWindow((Tk_Window) winPtr);
    }
}
- (void)windowUnmapped:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    NSWindow *w = [notification object];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);

    if (winPtr) {
	//Tk_UnmapWindow((Tk_Window) winPtr);
    }
}
- (void)windowClosed:(NSNotification *)notification {
#ifdef TK_MAC_DEBUG_NOTIFICATIONS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, notification);
#endif
    NSWindow *w = [notification object];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);

    if (winPtr) {
	TkGenWMDestroyEvent((Tk_Window) winPtr);
    }
}

#define observe(n, s) [nc addObserver:self selector:@selector(s) name:(n) object:nil]
- (void)_setupWindowNotifications {
    NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
    observe(NSWindowDidBecomeKeyNotification, windowActivation:);
    observe(NSWindowDidResignKeyNotification, windowActivation:);
    observe(NSWindowWillMoveNotification, windowDragStart:);
    observe(NSWindowDidMoveNotification, windowBoundsChanged:);
    observe(NSWindowDidResizeNotification, windowBoundsChanged:);
    observe(NSWindowWillStartLiveResizeNotification, windowLiveResize:);
    observe(NSWindowDidEndLiveResizeNotification, windowLiveResize:);
    observe(NSWindowDidDeminiaturizeNotification, windowExpanded:);
    observe(NSWindowDidMiniaturizeNotification, windowCollapsed:);
    observe(NSWindowWillOrderOnScreenNotification, windowMapped:);
    observe(NSWindowDidOrderOffScreenNotification, windowUnmapped:);
    observe(NSWindowWillCloseNotification, windowClosed:);
}
#undef observe(n, s)
@end

#pragma mark -

#ifdef MAC_OSX_TK_TODO
/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXProcessApplicationEvent --
 *
 *	This processes Application level events, mainly activate and
 *	deactivate.
 *
 * Results:
 *	0.
 *
 * Side effects:
 *	Hide or reveal floating windows.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXProcessApplicationEvent(
    TkMacOSXEvent *eventPtr,
    MacEventStatus *statusPtr)
{
    Tcl_CmdInfo dummy;

    /*
     * This is a bit of a hack. We get "show" events both when we come back
     * from being hidden, and whenever we are activated. I only want to run
     * the "show" proc when we have been hidden already, not as a substitute
     * for <Activate>. So I use this toggle...
     */

    static int toggleHide = 0;

    switch (eventPtr->eKind) {
    case kEventAppActivated:
	ShowFloatingWindows();
	break;
    case kEventAppDeactivated:
	TkSuspendClipboard();
	HideFloatingWindows();
	break;
    case kEventAppQuit:
	statusPtr->stopProcessing = 1;
	break;
    case kEventAppHidden:
	if (toggleHide == 0) {
	    toggleHide = 1;
	    if (eventPtr->interp && Tcl_GetCommandInfo(eventPtr->interp,
		    "::tk::mac::OnHide", &dummy)) {
		Tcl_GlobalEval(eventPtr->interp, "::tk::mac::OnHide");
	    }
	}
	statusPtr->stopProcessing = 1;
	break;
    case kEventAppShown:
	if (toggleHide == 1) {
	    toggleHide = 0;
	    if (eventPtr->interp && Tcl_GetCommandInfo(eventPtr->interp,
		    "::tk::mac::OnShow", &dummy)) {
		Tcl_GlobalEval(eventPtr->interp, "::tk::mac::OnShow");
	    }
	}
	statusPtr->stopProcessing = 1;
	break;
    case kEventAppAvailableWindowBoundsChanged: {
	static UInt32 prevId = 0;
	UInt32 id;
	OSStatus err;

	err = ChkErr(GetEventParameter, eventPtr->eventRef,
		kEventParamTransactionID, typeUInt32, NULL, sizeof(id), NULL,
		&id);
	if (err != noErr || id != prevId) {
	    TkDisplay *dispPtr = TkGetDisplayList();

	    prevId = id;
	    TkMacOSXDisplayChanged(dispPtr->display);
	}
	/*
	 * Should we call ::tk::mac::OnDisplayChanged?
	 */
	break;
    }
    default:
	break;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXProcessAppearanceEvent --
 *
 *	This processes Appearance events.
 *
 * Results:
 *	0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXProcessAppearanceEvent(
    TkMacOSXEvent *eventPtr,
    MacEventStatus *statusPtr)
{
    switch (eventPtr->eKind) {
    case kEventAppearanceScrollBarVariantChanged:
	TkMacOSXInitScrollbarMetrics();
	break;
    default:
	break;
    }
    return 0;
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * GenerateUpdates --
 *
 *	Given a Macintosh update region and a Tk window this function geneates
 *	a X Expose event for the window if it is within the update region. The
 *	function will then recursivly have each damaged window generate Expose
 *	events for its child windows.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Additional events may be place on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */

static int
GenerateUpdates(
    HIMutableShapeRef updateRgn,
    CGRect *updateBounds,
    TkWindow *winPtr)
{
    TkWindow *childPtr;
    XEvent event;
    CGRect bounds, damageBounds;
    HIShapeRef boundsRgn, damageRgn;

    TkMacOSXWinCGBounds(winPtr, &bounds);
    if (!CGRectIntersectsRect(bounds, *updateBounds)) {
	return 0;
    }
    if (!HIShapeIntersectsRect(updateRgn, &bounds)) {
	return 0;
    }

    /*
     * Compute the bounding box of the area that the damage occured in.
     */

    boundsRgn = HIShapeCreateWithRect(&bounds);
    damageRgn = HIShapeCreateIntersection(updateRgn, boundsRgn);
    if (HIShapeIsEmpty(damageRgn)) {
	CFRelease(damageRgn);
	CFRelease(boundsRgn);
	return 0;
    }
    HIShapeGetBounds(damageRgn, &damageBounds);
    ChkErr(TkMacOSHIShapeUnion, boundsRgn, updateRgn, updateRgn);
    HIShapeGetBounds(updateRgn, updateBounds);
    CFRelease(damageRgn);
    CFRelease(boundsRgn);

    event.xany.serial = Tk_Display(winPtr)->request;
    event.xany.send_event = false;
    event.xany.window = Tk_WindowId(winPtr);
    event.xany.display = Tk_Display(winPtr);
    event.type = Expose;
    event.xexpose.x = damageBounds.origin.x - bounds.origin.x;
    event.xexpose.y = damageBounds.origin.y - bounds.origin.y;
    event.xexpose.width = damageBounds.size.width;
    event.xexpose.height = damageBounds.size.height;
    event.xexpose.count = 0;
    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
#ifdef TK_MAC_DEBUG_DRAWING
    TKLog(@"Expose %p {{%d, %d}, {%d, %d}}", event.xany.window, event.xexpose.x,
	event.xexpose.y, event.xexpose.width, event.xexpose.height);
#endif

    /*
     * Generate updates for the children of this window
     */

    for (childPtr = winPtr->childList; childPtr != NULL;
	    childPtr = childPtr->nextPtr) {
	if (!Tk_IsMapped(childPtr) || Tk_IsTopLevel(childPtr)) {
	    continue;
	}
	GenerateUpdates(updateRgn, updateBounds, childPtr);
    }

    /*
     * Generate updates for any contained windows
     */

    if (Tk_IsContainer(winPtr)) {
	childPtr = TkpGetOtherWindow(winPtr);
	if (childPtr != NULL && Tk_IsMapped(childPtr)) {
	    GenerateUpdates(updateRgn, updateBounds, childPtr);
	}

	/*
	 * TODO: Here we should handle out of process embedding.
	 */
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * GenerateActivateEvents --
 *
 *	Given a Macintosh window activate event this function generates all
 *	the X Activate events needed by Tk.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Additional events may be place on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */

int
GenerateActivateEvents(
    Window window,		/* Root X window for event. */
    int activeFlag)
{
    TkWindow *winPtr;
    TkDisplay *dispPtr;

    dispPtr = TkGetDisplayList();
    winPtr = (TkWindow *) Tk_IdToWindow(dispPtr->display, window);
    if (winPtr == NULL || winPtr->window == None) {
	return false;
    }

    TkGenerateActivateEvents(winPtr,activeFlag);
    return true;
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXGenerateFocusEvent --
 *
 *	Given a Macintosh window activate event this function generates all
 *	the X Focus events needed by Tk.
 *
 * Results:
 *	True if event(s) are generated - false otherwise.
 *
 * Side effects:
 *	Additional events may be place on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */

MODULE_SCOPE int
TkMacOSXGenerateFocusEvent(
    Window window,		/* Root X window for event. */
    int activeFlag)
{
    XEvent event;
    Tk_Window tkwin;
    TkDisplay *dispPtr;

    dispPtr = TkGetDisplayList();
    tkwin = Tk_IdToWindow(dispPtr->display, window);
    if (tkwin == NULL) {
	return false;
    }

    /*
     * Don't send focus events to windows of class help or to windows with the
     * kWindowNoActivatesAttribute.
     */

    if (((TkWindow *)tkwin)->wmInfoPtr && (((TkWindow *)tkwin)->wmInfoPtr->macClass == kHelpWindowClass ||
	    ((TkWindow *)tkwin)->wmInfoPtr->attributes &
		    kWindowNoActivatesAttribute)) {
	return false;
    }

    /*
     * Generate FocusIn and FocusOut events. This event is only sent to the
     * toplevel window.
     */

    if (activeFlag) {
	event.xany.type = FocusIn;
    } else {
	event.xany.type = FocusOut;
    }

    event.xany.serial = dispPtr->display->request;
    event.xany.send_event = False;
    event.xfocus.display = dispPtr->display;
    event.xfocus.window = window;
    event.xfocus.mode = NotifyNormal;
    event.xfocus.detail = NotifyDetailNone;

    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
    return true;
}

/*
 *----------------------------------------------------------------------
 *
 * TkGenWMConfigureEvent --
 *
 *	Generate a ConfigureNotify event for Tk. Depending on the value of
 *	flag the values of width/height, x/y, or both may be changed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A ConfigureNotify event is sent to Tk.
 *
 *----------------------------------------------------------------------
 */

void
TkGenWMConfigureEvent(
    Tk_Window tkwin,
    int x,
    int y,
    int width,
    int height,
    int flags)
{
    XEvent event;
    WmInfo *wmPtr;
    TkWindow *winPtr = (TkWindow *) tkwin;

    if (tkwin == NULL) {
	return;
    }

    event.type = ConfigureNotify;
    event.xconfigure.serial = Tk_Display(tkwin)->request;
    event.xconfigure.send_event = False;
    event.xconfigure.display = Tk_Display(tkwin);
    event.xconfigure.event = Tk_WindowId(tkwin);
    event.xconfigure.window = Tk_WindowId(tkwin);
    event.xconfigure.border_width = winPtr->changes.border_width;
    event.xconfigure.override_redirect = winPtr->atts.override_redirect;
    if (winPtr->changes.stack_mode == Above) {
	event.xconfigure.above = winPtr->changes.sibling;
    } else {
	event.xconfigure.above = None;
    }

    if (!(flags & TK_LOCATION_CHANGED)) {
	x = Tk_X(tkwin);
	y = Tk_Y(tkwin);
    }
    if (!(flags & TK_SIZE_CHANGED)) {
	width = Tk_Width(tkwin);
	height = Tk_Height(tkwin);
    }
    event.xconfigure.x = x;
    event.xconfigure.y = y;
    event.xconfigure.width = width;
    event.xconfigure.height = height;

    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);

    /*
     * Update window manager information.
     */

    if (Tk_IsTopLevel(winPtr)) {
	wmPtr = winPtr->wmInfoPtr;
	if (flags & TK_LOCATION_CHANGED) {
	    wmPtr->x = x;
	    wmPtr->y = y;
	    wmPtr->flags &= ~(WM_NEGATIVE_X | WM_NEGATIVE_Y);
	}
	if ((flags & TK_SIZE_CHANGED) && !(wmPtr->flags & WM_SYNC_PENDING) &&
		((width != Tk_Width(tkwin)) || (height != Tk_Height(tkwin)))) {
	    if ((wmPtr->width == -1) && (width == winPtr->reqWidth)) {
		/*
		 * Don't set external width, since the user didn't change it
		 * from what the widgets asked for.
		 */
	    } else {
		if (wmPtr->gridWin != NULL) {
		    wmPtr->width = wmPtr->reqGridWidth
			    + (width - winPtr->reqWidth)/wmPtr->widthInc;
		    if (wmPtr->width < 0) {
			wmPtr->width = 0;
		    }
		} else {
		    wmPtr->width = width;
		}
	    }
	    if ((wmPtr->height == -1) && (height == winPtr->reqHeight)) {
		/*
		 * Don't set external height, since the user didn't change it
		 * from what the widgets asked for.
		 */
	    } else {
		if (wmPtr->gridWin != NULL) {
		    wmPtr->height = wmPtr->reqGridHeight
			    + (height - winPtr->reqHeight)/wmPtr->heightInc;
		    if (wmPtr->height < 0) {
			wmPtr->height = 0;
		    }
		} else {
		    wmPtr->height = height;
		}
	    }
	    wmPtr->configWidth = width;
	    wmPtr->configHeight = height;
	}
    }

    /*
     * Now set up the changes structure. Under X we wait for the
     * ConfigureNotify to set these values. On the Mac we know imediatly that
     * this is what we want - so we just set them. However, we need to make
     * sure the windows clipping region is marked invalid so the change is
     * visible to the subwindow.
     */

    winPtr->changes.x = x;
    winPtr->changes.y = y;
    winPtr->changes.width = width;
    winPtr->changes.height = height;
    TkMacOSXInvalClipRgns(tkwin);
}

/*
 *----------------------------------------------------------------------
 *
 * TkGenWMDestroyEvent --
 *
 *	Generate a WM Destroy event for Tk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A WM_PROTOCOL/WM_DELETE_WINDOW event is sent to Tk.
 *
 *----------------------------------------------------------------------
 */

void
TkGenWMDestroyEvent(
    Tk_Window tkwin)
{
    XEvent event;

    event.xany.serial = Tk_Display(tkwin)->request;
    event.xany.send_event = False;
    event.xany.display = Tk_Display(tkwin);

    event.xclient.window = Tk_WindowId(tkwin);
    event.xclient.type = ClientMessage;
    event.xclient.message_type = Tk_InternAtom(tkwin, "WM_PROTOCOLS");
    event.xclient.format = 32;
    event.xclient.data.l[0] = Tk_InternAtom(tkwin, "WM_DELETE_WINDOW");
    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
}

/*
 *----------------------------------------------------------------------
 *
 * TkWmProtocolEventProc --
 *
 *	This procedure is called by the Tk_HandleEvent whenever a
 *	ClientMessage event arrives whose type is "WM_PROTOCOLS". This
 *	procedure handles the message from the window manager in an
 *	appropriate fashion.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on what sort of handler, if any, was set up for the protocol.
 *
 *----------------------------------------------------------------------
 */

void
TkWmProtocolEventProc(
    TkWindow *winPtr,		/* Window to which the event was sent. */
    XEvent *eventPtr)		/* X event. */
{
    WmInfo *wmPtr;
    ProtocolHandler *protPtr;
    Tcl_Interp *interp;
    Atom protocol;
    int result;

    wmPtr = winPtr->wmInfoPtr;
    if (wmPtr == NULL) {
	return;
    }
    protocol = (Atom) eventPtr->xclient.data.l[0];
    for (protPtr = wmPtr->protPtr; protPtr != NULL;
	    protPtr = protPtr->nextPtr) {
	if (protocol == protPtr->protocol) {
	    Tcl_Preserve(protPtr);
	    interp = protPtr->interp;
	    Tcl_Preserve(interp);
	    result = Tcl_GlobalEval(interp, protPtr->command);
	    if (result != TCL_OK) {
		Tcl_AddErrorInfo(interp, "\n    (command for \"");
		Tcl_AddErrorInfo(interp,
			Tk_GetAtomName((Tk_Window) winPtr, protocol));
		Tcl_AddErrorInfo(interp, "\" window manager protocol)");
		Tk_BackgroundError(interp);
	    }
	    Tcl_Release(interp);
	    Tcl_Release(protPtr);
	    return;
	}
    }

    /*
     * No handler was present for this protocol. If this is a WM_DELETE_WINDOW
     * message then just destroy the window.
     */

    if (protocol == Tk_InternAtom((Tk_Window) winPtr, "WM_DELETE_WINDOW")) {
	Tk_DestroyWindow((Tk_Window) winPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_MacOSXIsAppInFront --
 *
 *	Returns 1 if this app is the foreground app.
 *
 * Results:
 *	1 if app is in front, 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tk_MacOSXIsAppInFront(void)
{
    OSStatus err;
    ProcessSerialNumber frontPsn, ourPsn = {0, kCurrentProcess};
    Boolean isFrontProcess = true;

    err = ChkErr(GetFrontProcess, &frontPsn);
    if (err == noErr) {
	ChkErr(SameProcess, &frontPsn, &ourPsn, &isFrontProcess);
    }

    return (isFrontProcess == true);
}

#ifdef MAC_OSX_TK_TODO
/*
 *----------------------------------------------------------------------
 *
 * ClearPort --
 *
 *	Clear (i.e. fill with transparent color) the given port.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
ClearPort(
    CGrafPtr port,
    HIShapeRef updateRgn)
{
    CGContextRef context;
    Rect bounds;
    CGRect rect;

    GetPortBounds(port, &bounds);
    QDBeginCGContext(port, &context);
    SyncCGContextOriginWithPort(context, port);
    CGContextConcatCTM(context, CGAffineTransformMake(1.0, 0.0, 0.0, -1.0, 0.0,
	    bounds.bottom - bounds.top));
    if (updateRgn) {
	ChkErr(HIShapeReplacePathInCGContext, updateRgn, context);
	CGContextEOClip(context);
    }
    rect = CGRectMake(0, 0, bounds.right, bounds.bottom);
    CGContextClearRect(context, rect);
    QDEndCGContext(port, &context);
}
#endif

#pragma mark TKContentView

#import <ApplicationServices/ApplicationServices.h>

/*
 * Custom content view for Tk NSWindows, containing standard NSView subviews.
 * The goal is to emulate X11-style drawing in response to Expose events:
 * during the normal AppKit drawing cycle, we supress drawing of all subviews
 * (using a technique adapted from WebKit's WebHTMLView) and instead send
 * Expose events about the subviews that would be redrawn.
 * Our Expose event handling then draws the subviews manually via their
 * -displayRectIgnoringOpacity:. Window flushing is suspended until all Expose
 * events for a given draw have been handled.
 */

@interface TKContentView(TKWindowEvent)
- (void)drawRect:(NSRect)rect;
- (void)generateExposeEvents:(HIMutableShapeRef)shape;
- (BOOL)isOpaque;
- (BOOL)wantsDefaultClipping;
- (BOOL)acceptsFirstResponder;
- (void)keyDown:(NSEvent *)theEvent;
@end

/* From WebKit/WebKit/mac/WebCoreSupport/WebChromeClient.mm: */
@interface NSWindow(TKSubwindows)
- (NSRect)_growBoxRect;
@end

@implementation TKContentView
@end

@implementation TKContentView(TKWindowEvent)

- (void)drawRect:(NSRect)rect {
    const NSRect *rectsBeingDrawn;
    NSInteger rectsBeingDrawnCount;
    [self getRectsBeingDrawn:&rectsBeingDrawn count:&rectsBeingDrawnCount];
#ifdef TK_MAC_DEBUG_DRAWING
    TKLog(@"-[%@(%p) %s%@]", [self class], self, _cmd, NSStringFromRect(rect));
    [[NSColor colorWithDeviceRed:0.0 green:1.0 blue:0.0 alpha:.1] setFill];
    NSRectFillListUsingOperation(rectsBeingDrawn, rectsBeingDrawnCount,
	    NSCompositeSourceOver);
#endif
    NSWindow *w = [self window];
    if ([w showsResizeIndicator]) {
	NSRect bounds = [self convertRect:[w _growBoxRect] fromView:nil];
	if ([self needsToDrawRect:bounds]) {
	    NSEraseRect(bounds);
	}
    }
    HIMutableShapeRef drawShape = HIShapeCreateMutable();
    while (rectsBeingDrawnCount--) {
	CGRect r = NSRectToCGRect(*rectsBeingDrawn++);
	HIShapeUnionWithRect(drawShape, &r);
    }
    if (CFRunLoopGetMain() == CFRunLoopGetCurrent()) {
	[self generateExposeEvents:drawShape];
    } else {
	[self performSelectorOnMainThread:@selector(generateExposeEvents:)
		withObject:(id)drawShape waitUntilDone:NO
		modes:[NSArray arrayWithObjects:NSRunLoopCommonModes,
			NSEventTrackingRunLoopMode, nil]];
    }
    CFRelease(drawShape);
}

- (void)generateExposeEvents:(HIMutableShapeRef)shape {
    NSWindow *w = [self window];
    TkWindow *winPtr = TkMacOSXGetTkWindow(w);
    CGRect updateBounds;

    if (!winPtr) {
	return;
    }
    HIShapeGetBounds(shape, &updateBounds);
    if (winPtr->wmInfoPtr && winPtr->wmInfoPtr->flags & WM_TRANSPARENT) {
#ifdef MAC_OSX_TK_TODO
	ClearPort(TkMacOSXGetDrawablePort(winPtr->window), shape);
#endif
    }
    if (GenerateUpdates(shape, &updateBounds, winPtr)) {
	/*
	 * Ensure there are no pending idle-time redraws that could prevent
	 * the just posted Expose events from generating new redraws.
	 */

	Tcl_DoOneEvent(TCL_IDLE_EVENTS|TCL_DONT_WAIT);
    }
}

#ifdef TK_MAC_DEBUG_DRAWING
- (void)setFrameSize:(NSSize)newSize {
    TKLog(@"-[%@(%p) %s%@]", [self class], self, _cmd, NSStringFromSize(newSize));
    [super setFrameSize:newSize];
}
- (void)setNeedsDisplayInRect:(NSRect)invalidRect {
    TKLog(@"-[%@(%p) %s%@]", [self class], self, _cmd,
	    NSStringFromRect(invalidRect));
    [super setNeedsDisplayInRect:invalidRect];
}
#endif
- (BOOL)isOpaque {
    return YES;
}

- (BOOL)wantsDefaultClipping {
    return NO;
}

- (BOOL)acceptsFirstResponder {
    return YES;
}

- (void)keyDown:(NSEvent *)theEvent {
#ifdef TK_MAC_DEBUG_EVENTS
    TKLog(@"-[%@(%p) %s] %@", [self class], self, _cmd, theEvent);
#endif
}

@end

#pragma mark TKContentViewPrivate

/*
 * Technique adapted from WebKit/WebKit/mac/WebView/WebHTMLView.mm to supress
 * normal AppKit subview drawing and make all drawing go through us.
 * Overrides NSView internals.
 */

@interface TKContentView(TKContentViewPrivate)
- (id)initWithFrame:(NSRect)frame;
- (void)_setAsideSubviews;
- (void)_restoreSubviews;
@end

@interface NSView(TKContentViewPrivate)
- (void)_recursiveDisplayRectIfNeededIgnoringOpacity:(NSRect)rect isVisibleRect:(BOOL)isVisibleRect rectIsVisibleRectForView:(NSView *)visibleView topView:(BOOL)topView;
- (void)_recursiveDisplayAllDirtyWithLockFocus:(BOOL)needsLockFocus visRect:(NSRect)visRect;
- (void)_recursive:(BOOL)recurse displayRectIgnoringOpacity:(NSRect)displayRect inContext:(NSGraphicsContext *)context topView:(BOOL)topView;
- (void)_lightWeightRecursiveDisplayInRect:(NSRect)visRect;
- (void)_drawRect:(NSRect)inRect clip:(BOOL)clip;
- (void)_setDrawsOwnDescendants:(BOOL)drawsOwnDescendants;
@end


@implementation TKContentView(TKContentViewPrivate)

- (id)initWithFrame:(NSRect)frame {
    self = [super initWithFrame:frame];
    if (self) {
	_savedSubviews = nil;
	_subviewsSetAside = NO;
	[self _setDrawsOwnDescendants:YES];
    }
    return self;
}

- (void)_setAsideSubviews
{
#ifdef TK_MAC_DEBUG
    if (_subviewsSetAside || _savedSubviews) {
	Tcl_Panic("TKContentView _setAsideSubviews called incorrectly");
    }
#endif
    _savedSubviews = _subviews;
    _subviews = nil;
    _subviewsSetAside = YES;
 }

 - (void)_restoreSubviews
 {
#ifdef TK_MAC_DEBUG
    if (!_subviewsSetAside || _subviews) {
	Tcl_Panic("TKContentView _restoreSubviews called incorrectly");
    }
#endif
    _subviews = _savedSubviews;
    _savedSubviews = nil;
    _subviewsSetAside = NO;
}

- (void)_recursiveDisplayRectIfNeededIgnoringOpacity:(NSRect)rect isVisibleRect:(BOOL)isVisibleRect rectIsVisibleRectForView:(NSView *)visibleView topView:(BOOL)topView
{
    [self _setAsideSubviews];
    [super _recursiveDisplayRectIfNeededIgnoringOpacity:rect isVisibleRect:isVisibleRect rectIsVisibleRectForView:visibleView topView:topView];
    [self _restoreSubviews];
}

- (void)_recursiveDisplayAllDirtyWithLockFocus:(BOOL)needsLockFocus visRect:(NSRect)visRect
{
    BOOL needToSetAsideSubviews = !_subviewsSetAside;
    if (needToSetAsideSubviews) {
        [self _setAsideSubviews];
    }
    [super _recursiveDisplayAllDirtyWithLockFocus:needsLockFocus visRect:visRect];
    if (needToSetAsideSubviews) {
        [self _restoreSubviews];
    }
}

- (void)_recursive:(BOOL)recurse displayRectIgnoringOpacity:(NSRect)displayRect inContext:(NSGraphicsContext *)context topView:(BOOL)topView
{
    [self _setAsideSubviews];
    [super _recursive:recurse displayRectIgnoringOpacity:displayRect inContext:context topView:topView];
    [self _restoreSubviews];
}

- (void)_lightWeightRecursiveDisplayInRect:(NSRect)visRect {
    BOOL needToSetAsideSubviews = !_subviewsSetAside;
    if (needToSetAsideSubviews) {
        [self _setAsideSubviews];
    }
    [super _lightWeightRecursiveDisplayInRect:visRect];
    if (needToSetAsideSubviews) {
        [self _restoreSubviews];
    }
}

- (void)_drawRect:(NSRect)inRect clip:(BOOL)clip {
#ifdef TK_MAC_DEBUG_DRAWING
    TKLog(@"-[%@(%p) %s%@]", [self class], self, _cmd, NSStringFromRect(inRect));
#endif
    BOOL subviewsWereSetAside = _subviewsSetAside;
    if (subviewsWereSetAside) {
        [self _restoreSubviews];
    }
    [super _drawRect:inRect clip:clip];
    if (subviewsWereSetAside) {
        [self _setAsideSubviews];
    }
}

@end

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 79
 * coding: utf-8
 * End:
 */
